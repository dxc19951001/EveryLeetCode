class Solution(object):
    def translateNum(self, num):
        """
        :type num: int
        :rtype: int
        """
        # 核心思路：
        # 本体也是运用动态规划的思路来进行求解，即得出的结果由前面的结果得出
        # 对于翻译方案来说，有分两种情况讨论
        # 第一种：单独选择第i个数，为最后一个数，则前i-1个数组成的翻译方案总和是此情况的结果，即dp[i-1]
        # 第二种：选择i和i-1组成的2位数，为最后一个数，则前i-2个数组成的翻译方案总和是此情况的结果，即dp[i-2]
        # 若选择i和i-1组成的2位数在[10, 25]，则方案总数为：dp[i-1]+dp[i-2]
        # 若选择i和i-1组成的2位数不在[10, 25]，即组成的二位数不符合要求，则方案总数为：dp[i-1]
        # 字母a-z对应于[0,25]，所以要排除组成的两位数为01、02...;26、27... 类似的数字

        #  当没有数字dp[0]，只有一种可能，dp[0]=1
        # 当有一个数字dp[1]，只有一种可能，dp[1]=1
        # 当有两个数字dp[2]，若第 1, 2位的组成的数字∈[10,25] 时，有两种情况，dp[2]=dp[1]+dp[0]=2
        # 求 dp[n]，即此数字的翻译方案数量。


        s = str(num)  
        # 将数字转换为字符串方便排除01、02..;26,27...这类数字
        a = b = 1
        # b代表dp[0] = 1
        # a代表dp[1] = 1
        
        # 采用滑动数组的方案，定义变量，a、b、c
        # 节省空间不用定义一个dp列表了
        # 每次a、b向前移动，在数字列表中取两个数
        # c为a+b或b 的结果
        for i in range(2, len(s) + 1):
            tmp = s[i - 2:i]
            # 判断i-1和i组成的两位是否符合要求
            # 符合：dp[i] = dp[i-1] + dp[i-2]，即a+b
            # 不符合：dp[i] = dp[i-1]，即a
            # c即代表dp[i]
            c = a + b if "10" <= tmp <= "25" else a
            b = a
            a = c
            # a和b向前进一步
        return a


s = Solution()
a = s.translateNum(' ')
print(a)
