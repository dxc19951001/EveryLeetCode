class Solution:
    def numTrees(self, n: int) -> int:

        # 核心思想
        # 动态规划
        # 给定一个有序序列1...n,为了构建出一棵二叉搜索树，我们可以遍历每个数字i，将该数字作为树根，
        # 将 1⋯(i−1) 序列作为左子树，将(i+1)⋯n 序列作为右子树。接着我们可以按照同样的方式递归构建左子树和右子树。
        # 在上述构建的过程中，由于根的值不同，因此我们能保证每棵二叉搜索树是唯一的。
        # 由此可见，原问题可以分解成规模较小的两个子问题，且子问题的解可以复用。因此，我们可以想到使用动态规划来求解本题。

        # dp(n): 长度为 n 的有序序列能构成的不同二叉搜索树的个数。
        # 注意到 dp[n] 和序列的内容无关，只和序列的长度有关
        # F(i, n): 以 i 为根、序列长度为 n 的不同二叉搜索树个数 (1 ≤ i ≤ n)。
        # 所以dp(n) = F(1, n) + F(2, n) + F(3, n) + ... + F(n, n)
        # 而F(i, n) = dp(i-1) * dp(n-i)，以i为根分开成左子树和右子树
        # 例如F(3,7) 分为 左子树有2个数，长度为2；右子树有4个数，长度为4，和结果为dp[2] * dp[4]
        # 得出递归方程为：
        # dp(n) = dp(1-1)*dp(n-1) + dp(2-1)*dp(n-2)+...+ dp(n-1)*dp(n-n)

        # 对于边界情况，当序列长度为 1（只有根）或为 0（空树）时，只有一种情况，即：
        # dp(0)=1
        # dp(1)=1

        dp = [0] * (n+1)
        dp[0] = 1
        dp[1] = 1
        
        for i in range(2, n+1):
            # n+1是为了能够取到第n个数
            # 循环计算dp[i]，即长度为 i 的有序序列能构成的不同二叉搜索树的个数
            for j in range(1, i+1):
                # i+1是为了能够取到第i个数
                # 从1开始循环，是因为：数值1, 2, ...i,作为根节点
                # 此层循环作用：
                # 计算长度为i的序列，以其中每一个数j作为根节点，所能构成的二叉树
                # dp[j-1]为左子树；dp[i-j]为右子树
                dp[i] += dp[j-1] * dp[i-j]

                # 例如dp[3],i = 3, j = 1 2 3，分别以1, 2, 3作为根节点
                # dp[3] = dp[0]*dp[2] + dp[1]*dp[1] + dp[2]*dp[0]
                #              1为根        2为根           3为根

        return dp[n]